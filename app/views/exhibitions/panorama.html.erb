<p id="notice"><%= notice %></p>
 <div id="main-container" class="container">


    <% panorama_url = attachment_url(@panorama, :image, :fill, 2048, 512, format: "png") %>
     <%= content_tag :div, class: "panorama_class", data: {panorama: panorama_url} do %>
     <% end %>



 <!DOCTYPE html>
 <html lang="en">
 	<head>
 		<title>Panorama</title>

    <style>
      #canvas {
        background-color: #000;
        width: 1400px;
        height: 600px;
        margin: 0px;
        padding: 0px;
        position: fixed; /* fixed or static */
        top: 130px;
        bottom: 20px;
        left: 0px;
      }
    </style>

 	</head>
 	<body>


           <script>
       			var container, stats;
       			var camera, scene, raycaster, renderer;
       			var mouse = new THREE.Vector2(), INTERSECTED;
       			var radius = 100, theta = 0;
            var array = [];


            CANVAS_WIDTH = 1400,
            CANVAS_HEIGHT = 600;

            var panoramUrl = $('.panorama_class').data('panorama');

       			init();
       			animate();


       			function init() {
       				container = document.createElement( 'div' );
              container.setAttribute("id", "canvas");
       				document.body.appendChild( container );

              renderer = new THREE.WebGLRenderer();

       				renderer.setClearColor( 0xf0f0f0 );
       				renderer.setSize( CANVAS_WIDTH, CANVAS_HEIGHT );
       				renderer.sortObjects = false;
       				container.appendChild(renderer.domElement);

       				scene = new THREE.Scene();

       			  camera = new THREE.PerspectiveCamera(46.6, CANVAS_WIDTH / CANVAS_HEIGHT, 0.1, 1000);

       				camera.position.x = 0;
              camera.position.y = 0;
              camera.position.z = 0;
              camera.lookAt(new THREE.Vector3(0, 0, 0 ));

       				var spotLight = new THREE.SpotLight(0xffffff);
       				spotLight.position.set(0, 150, 0);
       				spotLight.intensity = 1;
       				scene.add(spotLight);

       				var ambiLight = new THREE.AmbientLight(0xf4f5ec);
       				scene.add(ambiLight);

       				var cylinder = createCylinder(new THREE.CylinderGeometry(70, 70, 70, 30, 8, true), panoramUrl);

               cylinder.position.x = 0;
               cylinder.position.y = 0;
               cylinder.position.z = 0;
               cylinder.rotateY(3.14/2);

               scene.add(cylinder);

               function createCylinder(geom, imageFile) {

                    var loader = new THREE.TextureLoader();

                    var texture = loader.load(imageFile);

                    var mat = new THREE.MeshPhongMaterial();
                    mat.map = texture;
                    mat.side = THREE.DoubleSide;
                    var mesh = new THREE.Mesh(geom, mat);

                  return mesh;
              }

       				raycaster = new THREE.Raycaster();


              var sphere;
              var add = true;

              // setup the control gui
              var controls = new function () {
                  // we need the first child, since it's a multimaterial
                  this.radius = 5;

                  this.save = function () {
                      array.push([sphere.position.x, sphere.position.y, sphere.position.z, controls.radius]);
                      var sphereTwo = sphere;
                      add = true;
                      console.log(array);
                      console.log(controls.radius);
                  };

                  this.redraw = function () {
                      // remove the old plane
                      var posX = sphere.position.x;
                      var posY = sphere.position.y;
                      var posZ = sphere.position.z;
                      scene.remove(sphere);
                      // create a new one
                      sphere = createMeshSphr(new THREE.SphereGeometry(controls.radius, 30, 30));
                      // add it to the scene.
                      sphere.position.x = posX;
                      sphere.position.y = posY;
                      sphere.position.z = posZ;
                      scene.add(sphere);
                  };
              };

              var gui = new dat.GUI();
              gui.add(controls, 'radius', 0, 40).onChange(controls.redraw);
              gui.add(controls, 'save');

              render();

              function createMeshSphr(geom) {

                  // assign two materials
                  var meshMaterial = new THREE.MeshLambertMaterial({color: 0xe4e5f1, transparent:true, opacity: 0.3});
                  var wireFrameMat = new THREE.MeshLambertMaterial({color: 0xe4e5f1, transparent:true, opacity: 0.3});


                  // create a multimaterial
                  var mesh = THREE.SceneUtils.createMultiMaterialObject(geom, [meshMaterial, wireFrameMat]);

                  return mesh;
              }

              function onDocumentMouseMove( event ) {

           			event.preventDefault();
                mouse.x = ( ( event.clientX - container.offsetLeft ) / container.clientWidth ) * 2 - 1;
                mouse.y = - ( ( event.clientY - container.offsetTop ) / container.clientHeight ) * 2 + 1;

         			}

              function onDocumentMouseDown(event) {

                if (add){
                  var vector = new THREE.Vector2(( ( event.clientX - container.offsetLeft ) / container.clientWidth ) * 2 - 1,- ( ( event.clientY - container.offsetTop ) / container.clientHeight ) * 2 + 1);
                  var raycaster = new THREE.Raycaster();

                  raycaster.setFromCamera( vector, camera );

         					var intersects = raycaster.intersectObjects(scene.children);

                  sphere = createMeshSphr(new THREE.SphereGeometry(5, 30, 30));

                  sphere.position.z = intersects[0].point.z;
                  sphere.position.x = intersects[0].point.x;
                  sphere.position.y = intersects[0].point.y;

                  scene.add( sphere );

                  console.log(scene.children);

                  add = false;


                }

         			}

              function saveData(){
                array.push([sphere.position.z, sphere.position.x, sphere.position.y, sphere.radius ]);
              }


       				document.addEventListener( 'mousemove', onDocumentMouseMove, false );
       				document.addEventListener('mousedown', onDocumentMouseDown, false);
       				window.addEventListener( 'resize', onWindowResize, false );
       				document.addEventListener('keydown', turnRight, false);
       				document.addEventListener('keydown', turnLeft, false);
       				document.addEventListener('keyup', stop, false);

       			}

       			function onWindowResize() {

       				camera.aspect = window.innerWidth / window.innerHeight;
       				camera.updateProjectionMatrix();
       				renderer.setSize( window.innerWidth, window.innerHeight );

       			}

       			var turningRight = false;
       			var turningLeft = false;

       			function updateCameraObject(){

       				if (turningRight) {
       					camera.rotateY(-0.007);
       				} else if (turningLeft){
       					camera.rotateY(0.007);
       				}

       			}

       			function turnRight(event) {
       					if (event.keyCode === 39) { //right arrow key
       					turningRight = true;

       					}
       			}

       			function turnLeft(event) {
       					if (event.keyCode === 37) { //left arrow key
       					turningLeft=true;
       					}
       			}

       			function stop(event){
       				turningRight = false;
       				turningLeft = false;
       			}


       			function animate() {

       				requestAnimationFrame( animate );
       				render();

       			}

       			function render() {
       				updateCameraObject();
       				camera.updateMatrixWorld();
       				// find intersections
       				raycaster.setFromCamera( mouse, camera );
       				var intersects = raycaster.intersectObjects( scene.children );
       				if ( intersects.length > 0 ) {
       					if ( INTERSECTED != intersects[ 0 ].object ) {

       						if ( INTERSECTED ) INTERSECTED.material.opacity = 0;

       						INTERSECTED = intersects[ 0 ].object;
       						INTERSECTED.material.opacity = 0.4;

       					}
       				} else {

       					if ( INTERSECTED ) INTERSECTED.material.opacity = 0;

       					INTERSECTED = null;

       				}

       				renderer.render( scene, camera );

       			}

       		</script>

         </div>

 	</body>

 </html>
